# Issue #6: Redis Instance Provisioning and Management

**Priority**: High  
**Labels**: kubernetes, redis, deployment  
**Milestone**: Phase 2 - Kubernetes Integration  
**Estimated Effort**: 2-3 days

## Summary
Implement automated Redis deployment, configuration, and lifecycle management as part of the Kubernetes operator functionality.

## Motivation
The operator needs to create and manage actual Redis instances in response to RedisHttpInstance custom resources. This includes proper configuration, networking, persistence, and cleanup.

## Detailed Description

### Technical Requirements
- Redis StatefulSet deployment with persistent storage
- ConfigMap generation for Redis configuration
- Service creation for internal cluster access
- Volume management for persistence
- Resource limits and requests configuration

### Acceptance Criteria
- [ ] Redis StatefulSet template with proper configuration
- [ ] ConfigMap generation for Redis settings
- [ ] Persistent Volume Claims for data storage
- [ ] Service creation for cluster-internal access
- [ ] Resource limits based on instance specifications
- [ ] Health checks and readiness probes
- [ ] Proper cleanup on resource deletion
- [ ] Support for Redis configuration customization

### Implementation Details

#### Redis StatefulSet Template
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis-{{ .InstanceName }}
  namespace: {{ .Namespace }}
spec:
  serviceName: redis-{{ .InstanceName }}-headless
  replicas: 1
  selector:
    matchLabels:
      app: redis
      instance: {{ .InstanceName }}
  template:
    metadata:
      labels:
        app: redis
        instance: {{ .InstanceName }}
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
        volumeMounts:
        - name: data
          mountPath: /data
        - name: config
          mountPath: /usr/local/etc/redis/redis.conf
          subPath: redis.conf
        resources:
          requests:
            memory: {{ .Spec.RedisConfig.Memory }}
            cpu: 100m
          limits:
            memory: {{ .Spec.RedisConfig.Memory }}
            cpu: 500m
        livenessProbe:
          tcpSocket:
            port: 6379
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 5
          periodSeconds: 5
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi
```

#### Redis Configuration Management
```go
func (r *RedisHttpInstanceReconciler) generateRedisConfig(instance *redisv1alpha1.RedisHttpInstance) *corev1.ConfigMap {
    config := `
# Redis configuration generated by operator
bind 0.0.0.0
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300

# Memory configuration
maxmemory {{ .Spec.RedisConfig.Memory }}
maxmemory-policy allkeys-lru

# Persistence configuration
{{ if .Spec.RedisConfig.Persistence }}
save 900 1
save 300 10
save 60 10000
{{ else }}
save ""
{{ end }}

{{ if .Spec.RedisConfig.AppendOnly }}
appendonly yes
appendfsync everysec
{{ else }}
appendonly no
{{ end }}

# Security
protected-mode yes
requirepass {{ .GeneratedPassword }}
`
    
    return &corev1.ConfigMap{
        ObjectMeta: metav1.ObjectMeta{
            Name:      fmt.Sprintf("redis-%s-config", instance.Spec.InstanceName),
            Namespace: instance.Namespace,
        },
        Data: map[string]string{
            "redis.conf": config,
        },
    }
}
```

#### Service Creation
```go
func (r *RedisHttpInstanceReconciler) createRedisService(instance *redisv1alpha1.RedisHttpInstance) *corev1.Service {
    return &corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:      fmt.Sprintf("redis-%s", instance.Spec.InstanceName),
            Namespace: instance.Namespace,
            Labels: map[string]string{
                "app":      "redis",
                "instance": instance.Spec.InstanceName,
            },
        },
        Spec: corev1.ServiceSpec{
            Type: corev1.ServiceTypeClusterIP,
            Ports: []corev1.ServicePort{
                {
                    Port:       6379,
                    TargetPort: intstr.FromInt(6379),
                    Protocol:   corev1.ProtocolTCP,
                },
            },
            Selector: map[string]string{
                "app":      "redis",
                "instance": instance.Spec.InstanceName,
            },
        },
    }
}
```

#### Resource Management
- Dynamic resource allocation based on specifications
- Storage class selection for optimal performance
- CPU and memory limits enforcement
- Network policies for security isolation

### Definition of Done
- Redis instances are created successfully from CRD specifications
- Instances are properly configured with custom settings
- Persistent storage works correctly
- Health checks and monitoring are functional
- Resource cleanup happens automatically on deletion

### Dependencies
- Issue #5 (Kubernetes Operator Core)
- Issue #4 (Custom Resource Definitions)

### Additional Context
- Consider Redis Sentinel for high availability in future
- Implement backup and restore functionality
- Document Redis configuration options
- Plan for Redis cluster mode support